<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeScript小知识</title>
      <link href="/2022/11/27/TypeScript%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/11/27/TypeScript%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="易混淆区别"><a href="#易混淆区别" class="headerlink" title="易混淆区别"></a>易混淆区别</h2><h3 id="type和interface的不同点"><a href="#type和interface的不同点" class="headerlink" title="type和interface的不同点"></a>type和interface的不同点</h3><p>首先type可以做到，但interface不能做到的事情</p><ol><li>type可以定义 基本类型的别名，如 type myString = string</li><li>type可以通过 typeof 操作符来定义，如 type myType = typeof someObj</li><li>type可以申明 联合类型，如 type unionType = myType1 | myType2</li><li>type可以申明 元组类型，如 type yuanzu = [myType1, myType2] </li></ol><p>接下来interface可以做到，但是type不可以做到的事情<br>interface可以声明的变量多次，声明合并，只能声明对象式类型，type只能声明一次</p><h3 id="unknown和undefined的区别"><a href="#unknown和undefined的区别" class="headerlink" title="unknown和undefined的区别"></a>unknown和undefined的区别</h3><p>1.可以把任何值赋值给unknown，但是不能调用属性和方法，需要先断言<br>2.联合类型中有unknown，那么最终得到的都是unknown类型</p><h3 id="const和readonly区别"><a href="#const和readonly区别" class="headerlink" title="const和readonly区别"></a>const和readonly区别</h3><p>（1）const 用于变量， readonly 用于属性<br>（2）const 在运行时检查， readonly 在编译时检查<br>（3）const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值；<br>　　readonly 修饰的属性能确保自身不能修改属性，但是当你把这个属性交给其它并没有这种保证的使用者（出于类型兼容性的原因），他们能改变</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> foo<span class="token punctuation">:</span> <span class="token punctuation">{</span>readonly bar<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> bar<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">iMutateFoo</span><span class="token punctuation">(</span>foo<span class="token punctuation">:</span> <span class="token punctuation">{</span> bar<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  foo<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">iMutateFoo</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 456</span></code></pre><p>（4）const 保证的不是变量的值不得改动，而是变量指向的那个内存地址不得改动，例如使用 const 变量保存的数组，可以使用 push ， pop 等方法。<br>　　但是如果使用 ReadonlyArray<number> 声明的数组不能使用 push ， pop 等方法。　　</number></p><h2 id="手写实现类型"><a href="#手写实现类型" class="headerlink" title="手写实现类型"></a>手写实现类型</h2><pre class=" language-ts"><code class="language-ts">type ReturnType<span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">:</span><span class="token keyword">any</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">any</span><span class="token operator">></span> <span class="token operator">=</span> T <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">:</span><span class="token keyword">any</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> infer R <span class="token operator">?</span> R <span class="token punctuation">:</span><span class="token keyword">any</span><span class="token punctuation">;</span>type Pick<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>K <span class="token keyword">extends</span> <span class="token class-name">keyof</span> T<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">[</span>P <span class="token keyword">in</span> K<span class="token punctuation">]</span> <span class="token punctuation">:</span> T<span class="token punctuation">[</span>P<span class="token punctuation">]</span><span class="token punctuation">}</span> type Required<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token punctuation">[</span>P <span class="token keyword">in</span> keyof T<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token punctuation">:</span> T<span class="token punctuation">[</span>P<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>type Partial<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token punctuation">[</span>P <span class="token keyword">in</span> keyof T<span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">:</span> T<span class="token punctuation">[</span>P<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解读applyMiddleware、compose与redux-thunk源码</title>
      <link href="/2019/08/11/redux_applyMiddleware/"/>
      <url>/2019/08/11/redux_applyMiddleware/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么需要应用middleware"><a href="#为什么需要应用middleware" class="headerlink" title="为什么需要应用middleware"></a>为什么需要应用middleware</h3><p>在使用redux的情况下，经过middleware处理过的dispatch在自顶而下的单向数据流中能够完成更多自定义的特定事件，<br>例如：每次dispatch一个action需要打印信息来进行调试，就需要去改dispatch或者reducer代码，使其具有日志打印功能；此时我们又希望dispatch或者reducer具有异步请求的功能…</p><h3 id="compose组合函数"><a href="#compose组合函数" class="headerlink" title="compose组合函数"></a>compose组合函数</h3><p><code>dispatch = compose(...chain)(store.dispatch)</code><br>compose是函数式编程中的组合,compose将chain中的所有匿名函数[f1,f2,f3,…,fn]，组装成一个新的函数，即新的dispatch。当新的dispatch执行时，[f1,f2,f3,…,fn]依次从右往左执行。<br>Redux中compose源码实现是这样的。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * @param { ...Function } funcs The functions to compose. * @returns {Function} 一个从右至左参数函数组合获得的函数 * For example, compose(f, g, h) is identical to doing * (...args) => f(g(h(...args))). */</span> <span class="token keyword">function</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token operator">...</span>funcs<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>funcs<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> arg <span class="token operator">=</span><span class="token operator">></span> arg<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>funcs<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> funcs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> funcs<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>可以使用如下例子验证compose函数实现：</p><pre class=" language-javascript"><code class="language-javascript"> <span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token operator">+</span><span class="token string">'fn1'</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> <span class="token string">'fn1'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token operator">+</span><span class="token string">'fn2'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'fn2'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> funcs <span class="token operator">=</span> <span class="token punctuation">[</span>fn1<span class="token punctuation">,</span>fn2<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">compose</span><span class="token punctuation">(</span><span class="token operator">...</span>funcs<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="applyMiddleware源码"><a href="#applyMiddleware源码" class="headerlink" title="applyMiddleware源码"></a>applyMiddleware源码</h3><p>applyMiddleware 代码虽然只有二十多行，却非常精炼。<br>applyMiddleware 利用 createStore 和 reducer 创建了一个 store，然后 store 的 getState 方法和 dispatch 方法又分别被直接和间接地赋值给 middlewareAPI 变量  </p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> compose <span class="token keyword">from</span> <span class="token string">'./redux_compose.js'</span><span class="token comment" spellcheck="true">/** * @param {...Function} middlewares 应用改造的中间件链函数 * @returns {Function} 中间件增强后的store */</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">applyMiddleware</span><span class="token punctuation">(</span><span class="token operator">...</span>middlewares<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> createStore <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> dispatch <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'构建你的中间件时dispatch不被允许，其它中间件不会应用此dispatch'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> middlewareAPI <span class="token operator">=</span> <span class="token punctuation">{</span>            getState<span class="token punctuation">:</span>store<span class="token punctuation">.</span>getState<span class="token punctuation">,</span>            dispatch<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">const</span> chain <span class="token operator">=</span> middlewares<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>middleware <span class="token operator">=</span><span class="token operator">></span> <span class="token function">middleware</span><span class="token punctuation">(</span>middlewareAPI<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dispatch <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token operator">...</span>chain<span class="token punctuation">)</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>dispatch<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            <span class="token operator">...</span>store<span class="token punctuation">,</span>            dispatch        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>applyMiddleware的基本使用方式如下：</p><blockquote><p>eg: let store = applyMiddleware(mid1,mid2,mid3)(createStore)(reducer);  </p></blockquote><p>源码中middlewareAPI的dispatch为什么需要用匿名函数包裹呢？<br>如果直接取值store.dispatch的话，经过每层middleware改造后的dispatch就不能动态变化，它是应该是上层中间件传递过来的dispatch，而不是最外层写死的store.dispatch。</p><h3 id="redux-thunk异步中间件"><a href="#redux-thunk异步中间件" class="headerlink" title="redux-thunk异步中间件"></a>redux-thunk异步中间件</h3><p>redux-thunk源码十分简单，就数十行代码，是redux作者本人写的处理异步的中间件。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * redux-thunk中间件改造store.dispatch，使得后者可以接受函数作为参数 * @param {*} extraArgument  * @return {Function} */</span><span class="token keyword">function</span> <span class="token function">createThunkMiddleware</span><span class="token punctuation">(</span>extraArgument<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>dispatch <span class="token punctuation">,</span> getState<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> next <span class="token operator">=</span><span class="token operator">></span> action <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> action <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">action</span><span class="token punctuation">(</span>dispatch <span class="token punctuation">,</span> getState <span class="token punctuation">,</span> extraArgument<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> thunk <span class="token operator">=</span> <span class="token function">createThunkMiddleware</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>thunk<span class="token punctuation">.</span>withExtraArgument <span class="token operator">=</span> createThunkMiddleware<span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> thunk<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 个人对比理解为：</span><span class="token comment" spellcheck="true">// store或者{dispatch , getState}相当于applyMiddleware中middlewareAPI</span><span class="token comment" spellcheck="true">// next相当于store.dispatch，action就是下一个中间件</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>applyMiddleware 机制的核心在于组合 compose，将不同的 middleware 一层一层包裹到原生的 dispatch 之上，而为了方便进行 compose，需对 middleware 的设计采用柯里化 curry 的方式，达到动态产生 next 方法以及保持 store 的一致性。</p><p>参考资料<br><a href="https://zhuanlan.zhihu.com/p/20597452" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20597452</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
            <tag> redux-thunk </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 使用小结</title>
      <link href="/2019/08/11/hexo-use/"/>
      <url>/2019/08/11/hexo-use/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;使用 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>搭配github page可以快速构建属于自己的个人博客，几乎零成本，而且网上可以找到很多好看的主题，自己进行随心所欲的搭配，可以展示出程序猿内心深处细腻的一面！！！.     </p><p>&emsp;&emsp;跟随Hexo官方文档 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> 一步步操作可以很快完成博客的构建工作. 即使初次遇到不太会的问题，也可以在网上找到解决办法。</p><h2 id="Quick-Start-快速开始"><a href="#Quick-Start-快速开始" class="headerlink" title="Quick Start 快速开始"></a>Quick Start 快速开始</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"my article"</span></code></pre><p>详情访问: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>或</p><pre><code>$ hexo s</code></pre><p>详情访问 : <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><blockquote><p>建议在此之前使用 hexo clean命令 清理缓存和已生成的public资源文件</p></blockquote><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>或</p><pre><code>$ hexo g</code></pre><p>详情访问: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>也可以与generate命令结合使用</p><pre><code>$ hexo g -d </code></pre><p>详情访问: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><p>这一步操作后，博客文章生成并被推送到远程服务器上，完成博文发布 </p><h2 id="This-is-end"><a href="#This-is-end" class="headerlink" title="This is end"></a>This is end</h2><p>基本使用其实很简单，深入后续继续研究吧！<br>鉴于博主也才使用不久，各位看官希望发掘更多功能的话，那么快去看看文档吧！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
